// Automatically generated by AutoBindShader - 2015-04-09 16:28
#pragma once

#include <LibSL/GLHelpers/AutoBindShader.h>
#define vec2(x,y)	 V2F(x,y)
#define vec3(x,y,z)   V3F(x,y,z)
#define vec4(x,y,z,w) V4F(x,y,z,w)
namespace AutoBindShader {
class drawimage_sh_precompiled
{
protected:
    GLuint   m_TypeIn;
    GLuint   m_TypeOut;
    GLuint   m_MaxVerticesOut;
public:
#ifdef TW_INCLUDED
typedef struct { bool *member; Shader<drawimage_sh_precompiled> *owner; } t_cb_data;
#endif //TW_INCLUDED
   std::string name() { return "drawimage_sh"; }
		std::string csCode() {		  std::string cs_code;	return cs_code; }
		std::string vpCode() {		  std::string vp_code;		  vp_code = std::string("\
// SL 2012-02-08\n\
\n\
varying vec2 v_TexCoord;\n\
\n\
uniform vec2 u_Scale;\n\
uniform vec2 u_Translate;\n\
\n\
void main()\n\
{\n\
  vec2 uv     = gl_Vertex.xy*0.5+0.5;\n\
  v_TexCoord  = vec2( uv.x , 1.0-uv.y );\n\
  gl_Position = vec4( (gl_Vertex.xy*0.5+0.5) * u_Scale * 2.0 - 1.0 + u_Translate * 2.0 , 0.0 , 1.0 );\n\
}\n\
\n\
");
	return vp_code; }
		std::string fpCode() {		  std::string fp_code;		  fp_code = 
std::string("\
// SL 2012-02-08\n\
\n\
uniform sampler2D u_Image;\n\
\n\
varying vec2      v_TexCoord;\n\
\n\
uniform vec2      u_ImageSize;\n\
uniform vec4      u_UVWH;\n\
\n\
void main()\n\
{\n\
  vec2 uv         = ((v_TexCoord  * u_UVWH.zw) + u_UVWH.xy) / u_ImageSize.xy;\n\
  gl_FragColor    = texture2D( u_Image, uv );\n\
}\n\
\n\
");
	return fp_code; }
		GLShader::t_GeometryShaderNfo gsCode() {		  GLShader::t_GeometryShaderNfo gs;	return gs; }
void initParameters(GLShader& shader,bool firstInit) {
		  u_Scale.init( shader , "u_Scale" );
		  u_Translate.init( shader , "u_Translate" );
		  u_Image.init( shader , "u_Image" );
		  u_ImageSize.init( shader , "u_ImageSize" );
		  u_UVWH.init( shader , "u_UVWH" );
		  if ( firstInit ) {
			shader.begin();
			shader.end();
		  }
}
		drawimage_sh_precompiled() {
			}
		GLParameter u_Scale; /// vec2
		GLParameter u_Translate; /// vec2
		GLParameter u_Image; /// sampler2D
		GLParameter u_ImageSize; /// vec2
		GLParameter u_UVWH; /// vec4
#ifdef TW_INCLUDED
public:
public:
		TwBar *makeTwBar(Shader<drawimage_sh_precompiled> *owner)
		{
			TwBar *bar = TwNewBar("bar_drawimage_sh");
			return bar;
		}
		void initTweaks()
		{
		}
		void commitTweaks()
		{
		}
		void saveTweaks(const char *fname)
		{
		   FILE *f = NULL;
		   fopen_s(&f,fname,"wb");
		   sl_assert(f != NULL);
		   fclose(f);
		}
		void loadTweaks(const char *fname)
		{
		   FILE *f = NULL;
		   fopen_s(&f,fname,"rb");
		   sl_assert(f != NULL);
		   fclose(f);
		}
		static void TW_CALL defineGetCallBack(void *value	  , void *ptr) {
		  t_cb_data* d = (t_cb_data*) ptr; *(bool*)value = *(d->member); }
			static void TW_CALL defineSetCallBack(const void *value, void *ptr) {
		  t_cb_data* d = (t_cb_data*) ptr; *(d->member) = *(const bool*)value; d->owner->init(); }
#else  //TW_INCLUDED
    	void initTweaks()   { }
		void commitTweaks() { }
#endif //TW_INCLUDED
}; // class
typedef AutoBindShader::Shader<drawimage_sh_precompiled> drawimage_sh;} // namespace AutoBindShader;
#undef vec2
#undef vec3
#undef vec4
